import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';


let camera, scene, renderer;
let controller1, controller2;
let controllerGrip1, controllerGrip2;
let raycaster;
const intersected = [];
const tempMatrix = new THREE.Matrix4();
let originalColor = new THREE.Color();
//let group;

// create a new empty group to include imported models you want to interact with
let group = new THREE.Group();
group.name = 'Interaction-Group';



init();
initVR();
animate();


function init() {
    const container = document.createElement('div');
    document.body.appendChild(container);
    // camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 20);
    // camera.position.set(0, 0, 0);
    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
	camera.position.set( 0, 1.6, 3 );
    scene = new THREE.Scene();

    ///////////////////////BACKGROUND////////////////////////
    new RGBELoader()
        .load('kloppenheim_05_puresky_4k.hdr', function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture;
            render();
        });

    ////////////////////////scene///////////////////////////
    const loader = new GLTFLoader();
    loader.load('scenee.gltf', async function (gltf) {
        const polyworld = gltf.scene;
        polyworld.scale.set(0.1, 0.1, 0.1);
        polyworld.position.set(-1, 0.5, -4);
        await renderer.compileAsync(polyworld, camera, scene);
        scene.add(polyworld);
        render();
    });

    //const loaderr = new GLTFLoader();
    loader.load('cute_cat.gltf', async function (gltf) {
        const cat = gltf.scene;
        cat.scale.set(0.2, 0.2, 0.2);
        cat.position.set(-2, 0.7, -3);
       
        await renderer.compileAsync(cat, camera, scene);
        //scene.add(cat);
        group.add(cat);
    //    scene.add(gltfNoInteractions);
    //    group.add(gltfInteractions);
        render();
    });


    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.addEventListener('change', render);
    // controls.minDistance = 2;
    // controls.maxDistance = 10;
    // controls.target.set(0, -2, -4);
    controls.target.set( 0, 1.6, 0 );
    controls.update();

    window.addEventListener('resize', onWindowResize);
    // create a new empty group to include imported models you want to interact with
// create a new empty group to include imported models you want to interact with

    scene.add(group);

}

function initVR() {
    document.body.appendChild(VRButton.createButton(renderer));
    renderer.xr.enabled = true;

///////////////cintrollers//////////////////////
    controller1 = renderer.xr.getController( 0 );
    controller1.addEventListener( 'selectstart', onSelectStart );
    controller1.addEventListener( 'selectend', onSelectEnd );
    scene.add( controller1 );

    controller2 = renderer.xr.getController( 1 );
    controller2.addEventListener( 'selectstart', onSelectStart );
    controller2.addEventListener( 'selectend', onSelectEnd );
    scene.add( controller2 );

    controllerGrip1 = renderer.xr.getControllerGrip( 0 );
    scene.add( controllerGrip1 );

    controllerGrip2 = renderer.xr.getControllerGrip( 1 );
    scene.add( controllerGrip2 );

    //own model 1//
    const loader = new GLTFLoader();
    loader.load('cute_gun.gltf', async function (gltf) {
    gltf.scene.scale.set(0.05, 0.05, 0.05);
    let mymodel = gltf.scene;
    mymodel.rotation.y = THREE.MathUtils.degToRad(270);
    mymodel.rotation.x = THREE.MathUtils.degToRad(-36.5);
    mymodel.position.set(0, -0.1, 0);
    controllerGrip2.add(mymodel);
    });

    //own model 2//
    loader.load('pink_gun.gltf', async function (gltf) {
    gltf.scene.scale.set(0.005, 0.005, 0.005);
    let mymodel2 = gltf.scene;
    mymodel2.rotation.y = THREE.MathUtils.degToRad(90);
    mymodel2.rotation.x = THREE.MathUtils.degToRad(-36.5);
    mymodel2.position.set(0, -0.15, 0);
    controllerGrip1.add(mymodel2);
    });


    const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

    const line = new THREE.Line( geometry );
    line.name = 'line';
    line.scale.z = 5;

    controller1.add( line.clone() );
    controller2.add( line.clone() );

    raycaster = new THREE.Raycaster();

    //

    
    // renderer.setAnimationLoop(function () {
    //   // enderer.render(scene, camera);
    //    // cleanIntersected();
    //     // intersectObjects(controller1);
    //     // intersectObjects(controller2);
    //   //  controls.update();
    //     renderer.render(scene, camera);
        
    //});

    
}

// function onSelectStart(event) {}
// function onSelectEnd(event) {}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    render();
}
//let originalColor = object.color.clone();
function onSelectStart( event ) {

    
   
    const controller = event.target;

    const intersections = getIntersections( controller );

    if ( intersections.length > 0 ) {

        const intersection = intersections[ 0 ];

        const object = intersection.object;
    
        controller.attach( object );

        controller.userData.selected = object;

    }

    controller.userData.targetRayMode = event.data.targetRayMode;

}

function onSelectEnd( event ) {

    const controller = event.target;

    if ( controller.userData.selected !== undefined ) {

        const object = controller.userData.selected;
        group.attach( object );

        controller.userData.selected = undefined;

    }

}

function getIntersections( controller ) {

    controller.updateMatrixWorld();

    raycaster.setFromXRController( controller );

    return raycaster.intersectObjects(group.children, true);

}

function intersectObjects( controller ) {

    // Do not highlight in mobile-ar

    if ( controller.userData.targetRayMode === 'screen' ) return;

    // Do not highlight when already selected

    if ( controller.userData.selected !== undefined ) return;

    const line = controller.getObjectByName( 'line' );
    const intersections = getIntersections( controller );

    if ( intersections.length > 0 ) {

        const intersection = intersections[ 0 ];

        const object = intersection.object;
        originalColor.copy(object.material.color);

        object.material.color.set(0xff69b4);

        intersected.push( object );

        line.scale.z = intersection.distance;

    } else {

        line.scale.z = 5;

    }

}

function cleanIntersected() {

    while ( intersected.length ) {

        const object = intersected.pop();
        object.material.color.copy(originalColor);

    }

}

function animate() {
    renderer.setAnimationLoop( render );
    }


function render() {
    renderer.render(scene, camera);
    cleanIntersected();

    if (controller1 && controller2) {
        intersectObjects(controller1);
        intersectObjects(controller2);
    }
}

